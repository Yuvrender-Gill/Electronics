//===============================================================================================
// Implementing8 bit counter

module counter_4_bit(enable, clock, clear_b, q);
	input enable, clock, clear_b;
	output q; 
	
endmodule 

//===============================================================================================
// Implementing T-flipflop
module t-flipflop(t, clock, reset_n, q, not_q);
	input t, clock, reset_n;
	output q;
	wire wire_q, wire_not_q, mux_to_flipflop; // wires to connect the feedback to the muc
	assign q = wire_q;
	assign not_q = wire_not_q;
	mux2to1 mux(
					.x(wire_q),
					.y(wire_not_q),
					.s(t),
					.m(mux_to_flipflop)
					);
	d-flipflop flipflop(
							  .d(mux_to_flipflop),
							  .clock(clock),
							  .reset_n(reset_n),
							  .q(wire_q),
							  .not_q(wire_not_q)
							  );
							  
endmodule 				

//===============================================================================================
// Implementing D-flipflop

module d-flipflop(d, clock, reset_n, q, not_q);
		input d; // Data input fr the given register
		input clock; //Clock signal
		input reset_n; //to reset the register 
		output q; // output of the register. 
		output not_q;
		assign not_q = ~q;
		reg q;
		
		always @(posedge clock)
		
		begin
			if (reset_n == 1'b0)
				q <= 0;
			else
				q <= d;
		end
endmodule 

//================================================================================================
//Implementing mux2to1

module mux2to1(x, y, s, m);
    input x; //selected when s is 0
    input y; //selected when s is 1
    input s; //select signal
    output m; //output
  
    assign m = s & y | ~s & x;
    // OR
    // assign m = s ? y : x;
endmodule 